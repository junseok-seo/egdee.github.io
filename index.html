<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>egdee</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #000; }

    /* 배경 캔버스(공장) */
    #bgScene {
      position: fixed; inset: 0;
      filter: blur(6px) brightness(1.15) contrast(1.10) saturate(1.08);
      transform: scale(1.03);
    }

    /* 전경 캔버스(장비 패널) */
    #fgScene { position: fixed; inset: 0; }

    /* 중앙 텍스트 오버레이 */
    .overlay{
      position: fixed; inset: 0;
      display: grid;
      place-items: center;
      pointer-events: none;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Apple SD Gothic Neo", "Noto Sans KR", "Malgun Gothic", sans-serif;
      color: rgba(255,255,255,0.92);
      text-align: center;
      padding: 24px;
      z-index: 10;
    }
    .stack{
      display: grid;
      gap: 12px;
      place-items: center;
      transform: translateY(-6px);
    }
    h1{
      margin: 0;
      font-size: clamp(44px, 7vw, 86px);
      line-height: 1.0;
      letter-spacing: -0.03em;
      text-shadow: 0 14px 60px rgba(0,0,0,0.65);
    }
    p{
      margin: 0;
      font-size: clamp(14px, 1.6vw, 18px);
      line-height: 1.6;
      color: rgba(255,255,255,0.74);
      max-width: 62ch;
      text-shadow: 0 14px 60px rgba(0,0,0,0.65);
    }
    .ctaRow{
      margin-top: 10px;
      display: flex;
      gap: 12px;
      pointer-events: auto;
    }
    .btn{
      border-radius: 14px;
      padding: 12px 18px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      text-decoration: none;
      font-weight: 700;
      font-size: 14px;
      backdrop-filter: blur(12px);
    }
    .btn.primary{
      background: rgba(255,255,255,0.14);
      border-color: rgba(255,255,255,0.22);
    }

    .grain{
      position: fixed; inset: -30%;
      pointer-events: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='180' height='180'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='180' height='180' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      opacity: 0.055;
      mix-blend-mode: overlay;
      transform: rotate(8deg);
      z-index: 9;
    }
  </style>
</head>
<body>
  <div id="bgScene"></div>
  <div id="fgScene"></div>
  <div class="grain"></div>

  <div class="overlay">
    <div class="stack">
      <h1>egdee</h1>
      <p>Visualizing every noise in the world.</p>
      <!-- <div class="ctaRow">
        <a class="btn primary" href="#contact">Contact</a>
      </div> -->
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // =========================================================
    // 1) 배경: 3D 공장 씬
    // =========================================================
    const bgContainer = document.getElementById("bgScene");
    const bgRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    bgRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.25));
    bgRenderer.setSize(window.innerWidth, window.innerHeight);
    bgRenderer.setClearColor(0x030611, 1);
    bgContainer.appendChild(bgRenderer.domElement);

    const bgScene = new THREE.Scene();
    bgScene.fog = new THREE.Fog(0x030611, 10, 45);

    const bgCamera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 200);
    bgCamera.position.set(0, 3.1, 11.5);

    const bgKey = new THREE.DirectionalLight(0xffffff, 1.35);
    bgKey.position.set(6, 12, 8);
    bgScene.add(bgKey);

    const bgFill = new THREE.DirectionalLight(0xffffff, 0.65);
    bgFill.position.set(-10, 6, 4);
    bgScene.add(bgFill);

    bgScene.add(new THREE.AmbientLight(0xffffff, 0.28));

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(140, 140),
      new THREE.MeshStandardMaterial({ color: 0x0b1220, roughness: 0.92, metalness: 0.1 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -1.7;
    bgScene.add(floor);

    const matWall = new THREE.MeshStandardMaterial({ color: 0x1a2334, roughness: 0.88, metalness: 0.18 });
    const matMachine = new THREE.MeshStandardMaterial({ color: 0x232f45, roughness: 0.60, metalness: 0.28 });
    const pipeMat = new THREE.MeshStandardMaterial({ color: 0x304663, roughness: 0.45, metalness: 0.45 });

    function addPillar(x, z){
      const p = new THREE.Mesh(new THREE.BoxGeometry(0.7, 6.5, 0.7), matWall);
      p.position.set(x, 1.5, z);
      bgScene.add(p);
    }
    for (let i=-4;i<=4;i++){
      addPillar(i*3.4, -7);
      addPillar(i*3.4,  7);
    }

    for (let i=0;i<30;i++){
      const w = new THREE.Mesh(new THREE.BoxGeometry(2.8, 1.6 + Math.random()*2.2, 1.6 + Math.random()*2.9), matMachine);
      w.position.set((Math.random()-0.5)*22, -0.6 + w.geometry.parameters.height/2, (Math.random()-0.5)*18);
      w.rotation.y = (Math.random()-0.5)*0.7;
      bgScene.add(w);
    }

    for (let i=0;i<12;i++){
      const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.11, 20, 24), pipeMat);
      pipe.rotation.z = Math.PI/2;
      pipe.position.set((Math.random()-0.5)*14, 2.4 + Math.random()*2.2, (Math.random()-0.5)*12);
      bgScene.add(pipe);
    }

    const glow1 = new THREE.PointLight(0x7aa0ff, 1.2, 45);
    glow1.position.set(0, 6.8, 0);
    bgScene.add(glow1);

    const glow2 = new THREE.PointLight(0xffb84a, 0.9, 35);
    glow2.position.set(-6, 3.0, -4);
    bgScene.add(glow2);

    // =========================================================
    // 2) 전경: 디바이스 패널
    // =========================================================
    const fgContainer = document.getElementById("fgScene");
    const fgRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    fgRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    fgRenderer.setSize(window.innerWidth, window.innerHeight);
    fgRenderer.setClearColor(0x000000, 0);
    fgContainer.appendChild(fgRenderer.domElement);

    const fgScene = new THREE.Scene();
    const fgCamera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight, 0.1, 200);
    fgCamera.position.set(0, 0.25, 9.0);

    const fgKey = new THREE.DirectionalLight(0xffffff, 1.05);
    fgKey.position.set(6, 8, 7);
    fgScene.add(fgKey);

    const fgRim = new THREE.DirectionalLight(0xffffff, 0.55);
    fgRim.position.set(-7, 2, -7);
    fgScene.add(fgRim);

    fgScene.add(new THREE.AmbientLight(0xffffff, 0.12));

    const group = new THREE.Group();
    fgScene.add(group);

    // 디바이스 전체 크기
    const deviceScale = 0.78;
    group.scale.setScalar(deviceScale);
    group.position.set(0, 0, 0);

    // heatmap 텍스처
    const texSize = 768;
    const canvas = document.createElement("canvas");
    canvas.width = texSize; canvas.height = texSize;
    const ctx = canvas.getContext("2d");

    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;

    const W = 6.8, H = 4.05;
    const corner = 0.35;
    const depth = 0.25;

    function roundedRectShape(w, h, r){
      const s = new THREE.Shape();
      const x = -w/2, y = -h/2;
      s.moveTo(x+r, y);
      s.lineTo(x+w-r, y);
      s.absarc(x+w-r, y+r, r, -Math.PI/2, 0, false);
      s.lineTo(x+w, y+h-r);
      s.absarc(x+w-r, y+h-r, r, 0, Math.PI/2, false);
      s.lineTo(x+r, y+h);
      s.absarc(x+r, y+h-r, r, Math.PI/2, Math.PI, false);
      s.lineTo(x, y+r);
      s.absarc(x+r, y+r, r, Math.PI, Math.PI*1.5, false);
      return s;
    }

    const frameShape = roundedRectShape(W+0.55, H+0.55, corner+0.18);
    const frameGeo = new THREE.ExtrudeGeometry(frameShape, {
      depth,
      bevelEnabled: true,
      bevelThickness: 0.035,
      bevelSize: 0.04,
      bevelSegments: 4,
      curveSegments: 24
    });
    frameGeo.center();

    const frameMat = new THREE.MeshStandardMaterial({
      color: 0x0b101b,
      roughness: 0.55,
      metalness: 0.45,
      emissive: new THREE.Color(0x070b14),
      emissiveIntensity: 0.35
    });

    const frame = new THREE.Mesh(frameGeo, frameMat);
    frame.rotation.x = -0.16;
    frame.position.z = -0.22;
    group.add(frame);

    const frameEdges = new THREE.LineSegments(
      new THREE.EdgesGeometry(frameGeo, 12),
      new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.08 })
    );
    frameEdges.rotation.copy(frame.rotation);
    frameEdges.position.copy(frame.position);
    group.add(frameEdges);

    const screenGeo = new THREE.PlaneGeometry(W, H);
    const screenMat = new THREE.MeshStandardMaterial({
      map: texture,
      transparent: true,
      opacity: 0.98,
      roughness: 0.35,
      metalness: 0.05,
      emissive: new THREE.Color(0x071a3f),
      emissiveIntensity: 0.22,
      side: THREE.DoubleSide,
    });

    const screen = new THREE.Mesh(screenGeo, screenMat);
    screen.rotation.x = -0.16;
    screen.position.z = 0.0;
    group.add(screen);

    const border = new THREE.LineSegments(
      new THREE.EdgesGeometry(screenGeo, 10),
      new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.16 })
    );
    border.rotation.copy(screen.rotation);
    border.position.z = 0.02;
    group.add(border);

    const glass = new THREE.Mesh(
      new THREE.PlaneGeometry(W, H),
      new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0.08,
        metalness: 0.0,
        transmission: 1.0,
        thickness: 0.7,
        ior: 1.35,
        transparent: true,
        opacity: 0.20,
        clearcoat: 1.0,
        clearcoatRoughness: 0.10,
        side: THREE.DoubleSide
      })
    );
    glass.rotation.copy(screen.rotation);
    glass.position.z = 0.06;
    glass.material.depthWrite = false;
    glass.renderOrder = 10;
    group.add(glass);

    // 볼트
    const boltGeo = new THREE.CircleGeometry(0.05, 28);
    const boltMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.18, side: THREE.DoubleSide });
    function addBolt(x, y){
      const b = new THREE.Mesh(boltGeo, boltMat);
      b.rotation.copy(screen.rotation);
      b.position.set(x, y, 0.075);
      group.add(b);
    }
    const bx = W/2 - 0.18, by = H/2 - 0.18;
    addBolt(-bx,  by); addBolt(bx,  by);
    addBolt(-bx, -by); addBolt(bx, -by);

    // =========================================================
    // 1) 좌우측 선(스캔바) + 동그라미: 주황 계열로 통일
    // =========================================================
    const ORANGE = 0xff8a00;      // 메인 주황
    const ORANGE2 = 0xffb24d;     // 밝은 주황
    const ORANGE3 = 0xff5a1f;     // 붉은 주황

    // 스캔 바(주황 그라데이션)
    const scanCanvas = document.createElement("canvas");
    scanCanvas.width = 64; scanCanvas.height = 512;
    const sctx = scanCanvas.getContext("2d");
    const ograd = sctx.createLinearGradient(0,0,0,512);
    ograd.addColorStop(0.00, "rgba(255,138,0,0)");
    ograd.addColorStop(0.18, "rgba(255,138,0,0.75)");
    ograd.addColorStop(0.50, "rgba(255,178,77,0.95)");
    ograd.addColorStop(0.82, "rgba(255,90,31,0.70)");
    ograd.addColorStop(1.00, "rgba(255,138,0,0)");
    sctx.fillStyle = ograd;
    sctx.fillRect(0,0,64,512);
    const scanTex = new THREE.CanvasTexture(scanCanvas);

    const scanBar = new THREE.Mesh(
      new THREE.PlaneGeometry(0.12, H+0.05),
      new THREE.MeshBasicMaterial({ map: scanTex, transparent: true, opacity: 0.80, side: THREE.DoubleSide })
    );
    scanBar.rotation.copy(screen.rotation);
    scanBar.position.z = 0.09;
    scanBar.material.depthTest = false;
    scanBar.material.depthWrite = false;
    scanBar.renderOrder = 40;
    group.add(scanBar);

    const scanGlow = new THREE.Mesh(
      new THREE.PlaneGeometry(0.32, H+0.20),
      new THREE.MeshBasicMaterial({ color: ORANGE, transparent: true, opacity: 0.12, side: THREE.DoubleSide })
    );
    scanGlow.rotation.copy(screen.rotation);
    scanGlow.position.z = 0.085;
    scanGlow.material.depthTest = false;
    scanGlow.material.depthWrite = false;
    scanGlow.renderOrder = 39;
    group.add(scanGlow);

    // =========================================================
    // 2) 디바이스 배경에서 커졌다 작아졌다 하는 동그라미 제거
    //    -> (이전 pulse Mesh 제거 + 관련 애니메이션 제거)
    // =========================================================

    // =========================================================
    // 3) 마우스에 따라 움직이는 동그라미
    // =========================================================
    const ringMat = new THREE.MeshBasicMaterial({
      color: ORANGE2,
      transparent: true,
      opacity: 0.95,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });

    const ring2Mat = new THREE.MeshBasicMaterial({
      color: ORANGE3,
      transparent: true,
      opacity: 0.55,
      side: THREE.DoubleSide,
      depthTest: false,
      depthWrite: false
    });

    // ✅ 링 자체를 더 작게
    const ring  = new THREE.Mesh(new THREE.RingGeometry(0.11, 0.18, 72), ringMat);
    const ring2 = new THREE.Mesh(new THREE.RingGeometry(0.20, 0.215, 72), ring2Mat);

    ring.rotation.copy(screen.rotation);
    ring2.rotation.copy(screen.rotation);

    ring.position.z  = 0.16;
    ring2.position.z = 0.158;

    ring.renderOrder = 50;
    ring2.renderOrder = 51;

    group.add(ring);
    group.add(ring2);

    // 입력
    const mouse = { x: 0, y: 0, tx: 0, ty: 0 };
    window.addEventListener("pointermove", (e) => {
      mouse.tx = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.ty = (e.clientY / window.innerHeight) * 2 - 1;
    });

    const hotspot = { u: 0.5, v: 0.5, tu: 0.5, tv: 0.5 };

    function drawHeatmap(t){
      ctx.clearRect(0,0,texSize,texSize);

      ctx.fillStyle = "#040716";
      ctx.fillRect(0,0,texSize,texSize);

      // 그리드
      ctx.globalAlpha = 0.10;
      ctx.strokeStyle = "rgba(255,255,255,0.55)";
      ctx.lineWidth = 1;
      const step = 36;
      for(let x=0; x<=texSize; x+=step){
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,texSize); ctx.stroke();
      }
      for(let y=0; y<=texSize; y+=step){
        ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(texSize,y); ctx.stroke();
      }
      ctx.globalAlpha = 1.0;

      // 타원(blob) 제거됨

      // 스캔 라인(주황)
      const scanX = (0.5 + 0.45*Math.sin(t*0.7)) * texSize;
      const lg = ctx.createLinearGradient(scanX-10,0,scanX+10,0);
      lg.addColorStop(0.0, "rgba(0,0,0,0)");
      lg.addColorStop(0.5, "rgba(255,138,0,0.12)");
      lg.addColorStop(1.0, "rgba(0,0,0,0)");
      ctx.fillStyle = lg;
      ctx.fillRect(scanX-10, 0, 20, texSize);

      texture.needsUpdate = true;
    }

    const clock = new THREE.Clock();

    function tick(){
      const t = clock.getElapsedTime();

      // 배경 카메라 움직임
      bgCamera.position.x = Math.sin(t*0.10) * 1.3;
      bgCamera.position.y = 3.1 + Math.sin(t*0.08) * 0.35;
      bgCamera.position.z = 11.5 + Math.cos(t*0.07) * 0.5;
      bgCamera.lookAt(0, 1.4, 0);

      // 전경 마우스 스무딩
      mouse.x += (mouse.tx - mouse.x) * 0.08;
      mouse.y += (mouse.ty - mouse.y) * 0.08;

      // 패널 각도 변화
      group.rotation.y = mouse.x * 0.40;
      group.rotation.x = -mouse.y * 0.18;
      group.position.y = Math.sin(t * 0.55) * 0.05;

      // 동그라미가 끝으로 가지 않도록 마진
      const margin = 0.09;
      hotspot.tu = clamp(0.5 + mouse.x * 0.60, margin, 1 - margin);
      hotspot.tv = clamp(0.52 - mouse.y * 0.45, margin, 1 - margin);
      hotspot.u += (hotspot.tu - hotspot.u) * 0.12;
      hotspot.v += (hotspot.tv - hotspot.v) * 0.12;

      const px = (hotspot.u - 0.5) * W;
      const py = (hotspot.v - 0.5) * H;

      ring.position.set(px, py, ring.position.z);
      ring2.position.set(px, py, ring2.position.z);

      // 링은 깜빡임만 아주 살짝(원치 않으면 고정해도 됨)
      ring.material.opacity  = 0.82 + 0.12 * (0.5 + 0.5*Math.sin(t*2.2));
      ring2.material.opacity = 0.40 + 0.15 * (0.5 + 0.5*Math.sin(t*1.4));

      // 스캔 바 좌우 이동
      const sx = ((t * 0.26) % 1) * W - W/2;
      scanBar.position.set(sx, 0, scanBar.position.z);
      scanGlow.position.set(sx, 0, scanGlow.position.z);
      scanBar.material.opacity = 0.70 + 0.25 * (0.5 + 0.5*Math.sin(t*1.1));
      scanGlow.material.opacity = 0.08 + 0.10 * (0.5 + 0.5*Math.sin(t*1.1));

      // 유리 하이라이트
      glass.material.opacity = 0.16 + 0.12 * (0.5 + 0.5*Math.sin(t*0.9));

      drawHeatmap(t);

      bgRenderer.render(bgScene, bgCamera);
      fgRenderer.render(fgScene, fgCamera);

      requestAnimationFrame(tick);
    }
    tick();

    window.addEventListener("resize", () => {
      bgCamera.aspect = window.innerWidth / window.innerHeight;
      bgCamera.updateProjectionMatrix();
      bgRenderer.setSize(window.innerWidth, window.innerHeight);

      fgCamera.aspect = window.innerWidth / window.innerHeight;
      fgCamera.updateProjectionMatrix();
      fgRenderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

  <div id="contact" style="position: fixed; left:-9999px; top:-9999px;"></div>
</body>
</html>
